{"meta":{"title":"MadShawn's Pages","subtitle":"First github page","description":"不知道要写点啥","author":"MadShawn","url":"https://madshawn.github.io"},"pages":[{"title":"tags","date":"2017-09-11T11:13:20.000Z","updated":"2018-03-15T05:57:03.808Z","comments":false,"path":"tags/index.html","permalink":"https://madshawn.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2018-03-15T05:57:03.806Z","updated":"2018-03-15T05:57:03.806Z","comments":true,"path":"2018/03/15/hello-world/","link":"","permalink":"https://madshawn.github.io/2018/03/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Web代码注释规范","slug":"Web代码注释规范","date":"2018-03-14T15:22:35.000Z","updated":"2018-03-15T05:57:03.805Z","comments":true,"path":"2018/03/14/Web代码注释规范/","link":"","permalink":"https://madshawn.github.io/2018/03/14/Web代码注释规范/","excerpt":"","text":"前言为了提升代码的可读性和可维护性，同时为了提高代码总体的注释率，特制定此注释规范。本规范\b只针对Javascript文件，以支持ES6语法的EsDoc规范为基准，结合我们代码的现状，以及公司的相关要求，综合制定。主要包含以下几个方面的规定： 总的原则： 除类文件之外的所有文件必须有文件头注释 所有类文件必须有类注释 所有的全局变量必须有注释 所有的函数必须有注释 普通脚本文件 文件头 全局变量 函数 类文件 类注释 成员变量 成员函数 组件脚本文件 \b组件 内部变量 成员变量 \b内部函数 成员函数 其他规定 重要的公共函数 复杂逻辑代码 特殊处理代码 特殊需求代码 \b被注释的代码 普通脚本文件普通脚本文件是指无明确的组织结构，只是\b变量和函数组合的文件，比如WebApp项目中\b定义全局变量的Application.js、定义全局公共函数对象的Util.js等。注释规范如下： 文件头重要度： 必须有在文件最开始插入，描述文件的目的/内容/功能等，采用多行注释，如下Application.js文件头注释：123/** * 定义web app全局命名空间，并在此空间下定义属性和函数，以便全局使用 */ 全局变量重要度： 必须有全局变量指的是声明\b在window对象下的变量。如下Application.js文件中定义的全局变量的注释： 在使用了angular、vue、react等\b组件化的前端框架的单页面\bweb app中，此种意义上的全局\b变量应该很少1234567891011121314151617181920212223242526/** * App全局命名空间 * @type &#123;Object&#125; */var App = &#123;&#125;;/** * 全局配置信息 * @type &#123;Object&#125; * @property &#123;Object&#125; ml 大陆环境配置 * @property &#123;Object&#125; hm 港澳环境配置 */App.serverList = &#123; ml: &#123; /* trunk服务 */ serviceUrl: 'http://www.xxxx.com/service', /* trunk地图服务 */ subdomainsServiceUrl: 'http://www.xxxx.com/service' &#125;, hm: &#123; /* 港澳服务 */ serviceUrl: 'http://www.xxxx.com/hm/service', /* 港澳地图服务 */ subdomainsServiceUrl: 'http://www.xxxx.com/hm/service' &#125;&#125;; 函数重要度： 必须有无论是定义在脚本文件的全局函数，还是定义在类、组件、对象中的内部函数，都需要加完整的注释，注释规范如下：1234567891011121314151617181920/** * 从url地址中获取拼接的参数值 * @param &#123;String&#125; paramName 参数名称 * @return &#123;String&#125; 参数值 */getUrlParam: function (paramName) &#123; var reg = new RegExp('(^|&amp;)' + paramName + '=([^&amp;]*)(&amp;|$)'); var str = window.location.search; var ret; if (!str) &#123; str = window.location.hash; &#125; if (str) &#123; ret = str.substr(str.indexOf('?') + 1).match(reg); &#125; if (ret) &#123; return unescape(ret[2]); &#125; return null;&#125;, 类文件类文件是指使用es6的class语法定义的文件，一般一个类的定义是一个单独的文件，因此\b类文件可以没有文件头注释，以类注释替代。 类注释重要度： 必须有类注释与文件头注释类似，采用多行注释形式。类注释要放在import语句之后，类定义之前，且必须紧贴类定义，不能有空行。例子如下：12345678910111213141516171819202122232425262728293031import Singleton from './Singleton';/** * 对象控制器类的基类 */export default class Controller extends Singleton &#123; /** * 构造函数 * @param &#123;object&#125; options 可选项 * @return &#123;undefined&#125; */ constructor(options) &#123; super(options); &#125; /** * 清空 * @return &#123;undefined&#125; */ clear() &#123; &#125; /** * 销毁单例 * @return &#123;undefined&#125; */ destroy() &#123; this.clear(); super.destroy(); &#125;&#125; 成员变量重要度： 原则上都要有注释，尤其重要类、类的重要变量必须有成员变量分为普通成员变量和静态成员变量。普通成员指的是在contructor函数中定义在this下的变量；静态变量是以static关键词修饰的变量，注释的规范一样，如下边两个例子中的this._kvMap和instance变量： 普通成员变量 12345678910111213141516171819202122232425262728import Singleton from './Singleton';/** * 工厂类的基类 */export default class Factory extends Singleton &#123; /** * 构造函数 * @param &#123;object&#125; options 其他参数 * @return &#123;undefined&#125; */ constructor(options) &#123; super(options); /** * 配置表 * @type &#123;Object&#125; */ this._kvMap = &#123;&#125;; &#125; /** * 获取配置 * @return &#123;object&#125; 键值对对象 */ getConfig() &#123; return this._kvMap; &#125; 静态成员变量 1234567891011121314151617/** * 单例对象的实例 * @type &#123;class&#125; */static instance = null;/** * 获取单例对象的实例 * @param &#123;...all&#125; rest 参数 * @return &#123;class&#125; 单例对象的实例 */static getInstance(...rest) &#123; if (!this.instance) &#123; this.instance = new this(...rest); &#125; return this.instance;&#125; 成员函数重要度： 必须有成员函数也分为普通成员函数和静态成员函数。普通成员指的是在contructor函数中定义在this下的变量；静态变量是以static关键词修饰的变量，注释的规范一样，如下边两个例子中的getConfig和getInstance函数： 普通成员函数 12345678910111213141516171819202122232425262728import Singleton from './Singleton';/** * 工厂类的基类 */export default class Factory extends Singleton &#123; /** * 构造函数 * @param &#123;object&#125; options 其他参数 * @return &#123;undefined&#125; */ constructor(options) &#123; super(options); /** * 配置表 * @type &#123;Object&#125; */ this._kvMap = &#123;&#125;; &#125; /** * 获取配置 * @return &#123;object&#125; 键值对对象 */ getConfig() &#123; return this._kvMap; &#125; 静态成员函数 1234567891011121314151617/** * 单例对象的实例 * @type &#123;class&#125; */static instance = null;/** * 获取单例对象的实例 * @param &#123;...all&#125; rest 参数 * @return &#123;class&#125; 单例对象的实例 */static getInstance(...rest) &#123; if (!this.instance) &#123; this.instance = new this(...rest); &#125; return this.instance;&#125; 组件脚本文件组件脚本文件是\b\b指\b采用了angular、vue等前端框架\b之后，\b开发的各个组件对应的javascript脚本文件，如angular的module、controller、service等\b组件，vue的component文件等。下面是一个比较全的例子：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 文件头注释 * 地图工具面板组件的控制器 */angular.module('app').controller('MapAllToolbarPanelCtrl', ['$scope', '$rootScope', '$compile', '$timeout', function ($scope, $rootScope, $compile, $timeout) &#123; // var layerCtrl = fastmap.uikit.LayerController(); /** * 内部变量 * 形状编辑控制 * @type &#123;object&#125; */ var shapeCtrl = fastmap.uikit.ShapeEditorController(); /** * 成员变量 * 控制是否可编辑 * @type &#123;Boolean&#125; */ $scope.editable = false; /** * 内部函数 * 切换可编辑状态 * @param &#123;object&#125; event 页面事件 * @param &#123;object&#125; data 数据 * @return &#123;undefined&#125; */ var toggleEditable = function (event, data) &#123; $scope.editable = data.editable; &#125;; /** * 成员函数 * 讲工具从常用工具栏移入/移出 * @param &#123;object&#125; e 页面事件 * @return &#123;undefined&#125; */ $scope.toggleToRecent = function (e) &#123; if ($scope.editable) &#123; var elem = angular.element(e.currentTarget); var p = elem.parent(); if (p.hasClass('selected')) &#123; $scope.$emit('MapToolbar-removeTool', &#123; ngController: p.attr('ng-controller'), ngClick: p.attr('ng-click') &#125;); p.removeClass('selected'); &#125; else &#123; $scope.$emit('MapToolbar-addTool', &#123; title: p.attr('title'), ngController: p.attr('ng-controller'), ngClick: p.attr('ng-click'), ngClass: p.attr('ng-class'), icon: elem.html() &#125;); p.addClass('selected'); &#125; e.stopPropagation(); &#125; &#125;; 文件头重要度： 必须有见上例。 文件头注释与代码之间要加一个空行，防止esdoc将其认为是一个函数注释 内部变量重要度： 重要属性要有内部变量是指组件内的全局变量，对组件内的所有函数可见。注释规范同变量，见上例。 成员变量重要度： 重要\b变量要有成员变量是指\b定义在\b组件特定命名空间下的变量，如上例中的$scope中的变量。注释规范同变量，见上例。 内部函数重要度： 必须有内部函数是指组件内的全局函数，对组件内的其他所有函数可见。注释规范同函数，见上例。 成员函数重要度： 必须有成员函数是指\b定义在\b组件特定命名空间下的函数，如上例中的$scope中的函数。注释规范同函数，见上例。 其他规定重要的公共函数重要度： 必须有 基类中被多个子类调用的 常用的函数 此类函数要加上详细的函数说明，并要对函数参数进行详细的说明，如值域、\b对象的\b固有属性等。 复杂逻辑代码重要度： 必须有 判断条件超过3个的 循环/判断超过2层嵌套的 特殊处理代码重要度： 必须有 循环中的特殊判断跳出 变量的特殊赋值12345// add by chenx on 2017-4-27// 解决切换任务后，地图不能正常加载的问题$timeout(function () &#123; $scope.$broadcast('Map-Initialize');&#125;, 100); 特殊需求代码重要度： 必须有 用户提出的一些特殊处理需求 被注释的代码重要度： 必须有如果是由于某些情况临时注释，后续有可能有用的代码，则必须加注释信息； 需求/Bug/生产问题的注释\b对应需求、bug和生产问题时修改的代码，如果是符合其他规定中的内容的，需要\b加上对应的注释。正常的任务开发和bug修改只需要在提交代码时，在commit信息里写清楚具体的需求、任务、bug编号即可，以便在github上追溯。 esdoc生成器 npm安装 12npm install esdocnpm install esdoc-standard-plugin esdoc使用 1./node_modules/.bin/esdoc 参考esdoc官网","categories":[],"tags":[{"name":"编码规范","slug":"编码规范","permalink":"https://madshawn.github.io/tags/编码规范/"}]},{"title":"审图项目工作计划","slug":"审图项目工作计划","date":"2017-10-25T14:18:03.000Z","updated":"2018-03-15T05:57:03.807Z","comments":true,"path":"2017/10/25/审图项目工作计划/","link":"","permalink":"https://madshawn.github.io/2017/10/25/审图项目工作计划/","excerpt":"","text":"前言接到一个审图的项目，功能较小，打算我们包揽前后端以及数据库，这里列一下大体的工作安排和计划。 时间和资源 时间设计3天，10月27日出设计开发3周，10.30-11.17 人员两个人：wz，ll 工作计划设计 负责人： cx 技术选型 前端框架vue 地图组件mapbox-gl 服务框架nodejs-express 功能设计这里首先澄清两个概念：管理员录入的问题，我们称之为 案例（Case）作业员针对 案例(Case) 录入的问题，我们称之为 问题（Issue） 总体功能目标 管理员录入案例 作业员创建项目，并在项目中针对所有案例录入问题 管理员对作业员录入的项目、问题进行审核 对于审核不通过的项目和问题作业员要进行修改、重新提交审核 审核通过的项目直接成为完成的项目 详细设计 用户登录 用户分角色控制，两种角色：管理员和作业员 管理员要能审核项目，能录入案例；作业员能创建项目、录入项目问题、提交项目； 实时地图数据查看 管理员-案例的增删改 管理员-案例列表，以及逐条查看 管理员-案例录入支持照片、视频的上传，以及查看 管理员-案例录入时，支持在地图上标记点位，一个案例对应一个点位，方便定位 管理员-案例录入保存时，要记录标记点，以及缩放等级，以便查看时对应定位地图 管理员-案例要分用户存储，即要记录创建用户 如果在地图上需要手绘图形，可以用jquery的wPaint、Zwibbler等插件 作业员-能创建、查看项目 作业员-进入项目后，能看到地图、案例列表（所有的） 作业员-能针对案例逐条录入问题，能增删改，能上传图片、视频； 作业员-系统显示案例列表时，要能区分出那些录入了问题，那些没录，方便作业员录入； 作业员录入完项目的所有案例问题后，可提交项目给指定的管理员进行审核； 管理员审核项目问题时，系统对案例列表的显示要能体现出案例的问题审核状态：待审核，审核通过，审核不通过； 管理员可对案例问题执行审核通过、审核不通过操作，不通过时可以录入备注信息； 数据库设计 管理表 用户信息表 （用户，登录token，登录状态） 角色信息表 权限信息表 用户角色关系表 角色权限关系表 日志表？ 业务表 项目信息表（项目ID，项目信息，创建人，创建时间，提交时间，项目状态，审核状态，审核人，审核时间，审核备注） 项目审核历史表（项目ID，审核人，审核时间，审核状态，审核备注） 案例信息表(案例ID，案例信息，创建时间，创建的管理员) 案例问题表（问题ID，项目ID，案例ID，问题内容，问题状态，审核人，审核时间，审核状态，审核备注）； 问题审核历史表（问题ID，审核人，审核时间，审核状态，审核备注） 接口设计 登录（om/login）（返回用户信息、角色、权限等） 项目创建（task/create） 项目修改（task/update） 项目删除（task/delete） 项目列表（task/list） 项目详情（task/query） 项目提交（task/submit） 项目审核通过（task/audit/ok） 项目审核不通过（task/audit/no） 案例列表（case/list） 案例详情（case/query） 案例新增（case/create） 案例修改（case/update） 案例删除（case/delete） 案例附件上传（case/file/upload） 案例问题关联列表（issue/case/list） —用于在项目中显示案例 案例问题详情（issue/case/query） —用于在项目中显示案例 案例问题文件上传（issue/file/upload） —上传问题附件 案例问题更新（issue/update） —更新问题案例问题（上传文件后自动执行） 案例问题审核通过（issue/audit/ok） 案例问题审核不通过（issue/audit/no） 开发 项目分为多期实现第一期, 三周时间，实现管理员录入案例，作业员能针对案例录入问题功能即可。后续逐步实施审核流转功能； 第一周 前后端开发框架搭建； 实现用户登录，web+服务 实现项目列表，web+服务 第二周 地图加载 案例列表 案例的增删改查 项目创建 项目查询 案例问题列表 案例问题的增删改查 第三周 遗留问题的处理 用户试用，并提出改善 对应用户提的改善问题","categories":[],"tags":[{"name":"工作计划","slug":"工作计划","permalink":"https://madshawn.github.io/tags/工作计划/"}]},{"title":"vue+cesium的项目搭建","slug":"vue-cesium的项目搭建","date":"2017-09-26T18:09:08.000Z","updated":"2018-03-15T05:57:03.807Z","comments":true,"path":"2017/09/27/vue-cesium的项目搭建/","link":"","permalink":"https://madshawn.github.io/2017/09/27/vue-cesium的项目搭建/","excerpt":"","text":"前言上周有一个在大屏幕上展示作业进展情况的需求，需要在一个地球上动态展示作业分布，以及一些其他的图表显示。我们打算采用流行的vue前端框架，地球的显示采用Cesium库，前端工程使用es6语法来写，使用webpack进行构建。由于新接触Vue框架以及Cesium库，因此在搭建前端工程的时候遇到了几个典型的问题，在这里进行总结记录。 vue框架搭建软硬件环境 操作系统：win2010 开发工具：vs code 软件环境：nodejs-7.7.3，npm-4.1.2 工程搭建我们使用vue-cli命令行工具, 搭建使用webpack来构建的工程。 安装vue-cli命令行工具： npm install -g vue-cli 创建vue工程： vue init webpack my-proj 上述命令中， vue init 是命令，webpack 表示使用webpack工程模版，my-proj 是自定义的工程名称。vue-cli命令行工具就不详细介绍了，网上的相关文章很多，npm官方连接。使用 vue help命令，也能得到详细的帮助信息。 执行上述命令后，会有很多yes/no的选择，以及一些简单的输入。主要涉及到工程名称、描述等，是否引入测试框架等等，主要用于生成工程的package.json，根据实际需要选择和输入即可。 执行完所有输入后，vue-cli会将工程初始化出来，创建相应的目录和文件。目录结构如下： my-proj ├─build // webpack配置文件以及用于构建的js文件 ├─config // webpack配置和构建文件中用到的配置信息文件 ├─src // 源代码目录 │ ├─assets // 静态文件目录，如图片等 │ ├─components // vue组件目录 │ └─router // vue-router文件目录 ├─static // 外部的静态文件，webpack会在构建的时候把这里的文件拷贝到构建目录中 └─test // 测试相关的文件目录，在创建工程时引入了测试框架的才会有 └─unit └─specs // 下边其实还有babel、eslint、package.json等配置文件，window的tree命令没列出来。。。 此时，依赖的包只是被写入到了package.json中，并没有安装。进入工程的根目录，安装依赖的包： npm install 测试工程： 执行如下命令： npm run dev 启动一个express服务器，自动打开默认浏览器，会看到一个vue的欢迎页面，说明工程创建成功。 webpack构建过程介绍 下面是webpack构建用到的配置文件的介绍 my-proj │ package.json // 工程的npm配置文件 │ ├─build │ build.js // 构建产品版程序的启动文件 │ check-versions.js // 检查node、npm以及依赖包的版本 │ dev-client.js // 这个没研究是干啥的 │ dev-server.js // 构建开发版程序，启动express服务器的启动文件 │ utils.js // 提供一些处理目录等的工具函数 │ vue-loader.conf.js // vue加载器的配置文件，没仔细研究 │ webpack.base.conf.js // webpack的公共配置 │ webpack.dev.conf.js // webpack的开发版配置，会包含base.conf.js │ webpack.prod.conf.js // webpack的产品版配置，会包含base.conf.js │ webpack.test.conf.js // webpack的测试版配置，会包含base.conf.js │ ├─config │ dev.env.js // 开发版的环境变量配置 │ index.js // 主配置文件，配置了构建的目录、项目的相对路径、静态文件子目录等，会在webpack.conf文件中引用 │ prod.env.js // 产品版的环境变量配置 │ test.env.js // 测试版的环境变量配置 │ 开发版的构建和启动流程 执行 npm run dev 启动开发版构建； npm调用node执行 build/dev-server.js(见package.json中scripts的配置)； 调用webpack，使用webpack.dev.conf.js配置进行构建； 构建好之后，根据config/index.js中配置的端口等启动express服务器； 调用默认浏览器，显示构建好的页面； 注意：无论是express还是下边要讲的webpack-dev-server（应该也是express的一种），webpack构建出来的目录对他们来说都只有静态文件有用，程序文件如index.html、app.js都是直接在server的内存中的，不是直接使用构建目录下的文件。以上是我个人的理解，例证就是：对于这里的express服务器，构建完成之后，就没有生成新的目录和文件。而对于webpack-dev-server，虽然生成了构建目录目录和文件，但是如果构建出来的js文件名是带hash值的，可以在Chrome浏览器的开发者工具中看到，页面加载的js的hash值，与构建目录下的js的hash值是不一样的。 产品版的构建流程 执行 npm run build； 调用node执行 build/build.js； 引入rimraf组件，删除构建目录中的已有文件； 删除完成后，启动webpack使用webpack.prod.conf.js配置执行构建； 这里对webpack的配置和使用就不做详细说明了，如果不清楚的可以看我之前了解webpack时写的webpack资料总结。 引入Cesium库在引入Cesium库的过程中，我们找到了以下几种方案，分别说明： Cesium开源版（org网站）的官方指导 这个方案介绍的是在Cesium工程的基础上进行开发的流程，我们是想向vue工程中引入cesium，因此不太适用。 当然如果想用传统方案，通过下载cesium整个包到工程目录中，然后在html里通 &lt;script&gt; &lt;link&gt; 来直接引用相关的js和css也是没有问题的。 这里我们想用webpack进行包管理和自动化构建，因此不采用此方案。 webpack-cesium,这个是后来找到的，还没使用，不做说明； Cesium商用版（com网站）中找到的Cesium and webpack 这里介绍的通过webpack引入cesium方案正是我们想要的。下面就详细介绍引入cesium的辛酸过程。。。。 安装Cesium包官方文档里给的例子中，是下载Cesium包，然后拷贝到工程的lib目录中，我们当然不会这么老实。。。在这里我们知道cesium是可以通过npm安装的，太好了！执行下面命令： npm install cesium -S 安装完成后，会在工程的node_modules中找到cesium文件夹，目录说明如下： ├─Build // 预编译好的文件目录 │ ├─Cesium // 预编译且压缩的文件 │ └─CesiumUnminified // 预编译未压缩的文件 └─Source // 源代码目录 代码中引入按照官方文档说明，在我们工程的vue地球组件中加入以下代码： window.CESIUM_BASE_URL = &apos;./static/Cesium&apos;; // 构建好之后，我们要把Cesium的文件放在项目下的static/Cesium/文件夹中，因此要这样配置 // 注意：这里要用Source下的文件，原因下边有说明 let Cesium = require(&apos;../../node_modules/cesium/Source/Cesium.js&apos;); require(&apos;../../node_modules/cesium/Source/Widgets/widgets.css&apos;); // html元素，以及页面初始化viewer 不再列出 这里有三个地方与官方文档不一样： CESIUM_BASE_URL 路径 我们因为按照vue-cli创建的工程中，默认要把webpack构建的出来的项目种，静态文件要放在static二级目录下，所以要这样配置。 引用了Source下的文件 官方文档里建议引用预编译好的文件，即Build下的Cesium或者CesiumUnminified，我们这里引用的是Source下的文件。 因为如果引用Build下的文件，构建好的项目启动后，会在浏览器的控制台报出一个错误，导致页面不能显示： Uncaught Error: Cesium missing ThirdParty/pako_inflate 解决方案就是换成Source下的文件，解决方案来源于 这里 的负一楼。 这里没有采用let Cesium = window.Cesium 的写法 如果采用官方推荐的写法，当使用 Cesium 对象初始话地图的时候，页面中会报 Cesium对象undefined的问题。 启动开发服务器此时，我们披荆斩棘，已经把代码写好了，该是启动服务器验证一下页面的时候了。启动开发服务器的命令： npm run dev 或者 npm start 第一次出现的错误这时我们发现构建过程中报了一个错误： ERROR Failed to compile with 1 errors This dependency was not found: * fs in ./~/cesium/Source/ThirdParty/crunch.js To install it, you can run: npm install --save fs 在检查了package.json以及node_modules下文件夹后，我们确定是已经安装了fs包的。尽管如此，我们还是按照提示，再一次执行安装 npm install -S fs , 安装了之后再编译，还是报同样的错误。。。只能google了，在 这里 找到了解决方法，我们修改工程中 build/webpack.base.conf.js 配置文件，代码如下： *** module: { *** }, // 配置的最外层 externals: { &apos;fs&apos;: true, } 注意：这里要修改base配置文件，因为dev、prod、test的都会merge这个文件，只用改一处地方就可以了 第二次出现的错误重新启动开发服务器（npm run dev），构建没有报错，页面打开了，但是只有个黑黑的背景以及报错信息。f12打开Chrome的控制台，我们发现有几个相同的报错： Error: Cannot find module &quot;.&quot; 继续google，在 这里 找到了解决方法。继续修改 build/webpack.base.conf.js 配置文件，代码如下： *** module: { rules: [ *** ], ***, // module选项内 unknownContextCritical: false, unknownContextRegExp: /^.\\/.*$/ }, // 配置的最外层 externals: { &apos;fs&apos;: true, } 第三次出现的错误再次启动开发服务器（npm run dev），构建没有报错，页面打开了，出现了黑黑的地图背景，还有地图工具栏，但是等等，为什么有很多图片加载失败？官方文档中其实已经说过了：像Cesium这么复杂的库，你想只通过 require(&#39;Cesium&#39;) 一句代码就引入到你的工程中去，那就图样图森破了。在代码中写的 window.CESIUM_BASE_URL 就是用来配置指向其他依赖的文件的根目录的。既然想到了这个，那就有办法了，我们把编译好的Cesium依赖文件，拷贝到webpack构建的项目的指定目录下就行了吧，也就是指定给 window.CESIUM_BASE_URL 变量的目录。但是还有个问题，我们发现执行完 npm run dev 后，webpack根本就没有生成配置文件定义的dist目录，猜测它是直接把构建好的文件扔到了express服务器的内存中去执行了，没有构建目录，我们往哪儿拷贝，怎么让express服务器知道Cesium依赖的静态文件在哪儿？研究了半天，答案是 没办法 ，我也很无奈啊！ 用tomcat验证方案我们可以换个思路，但是首先我们想验证下我之前想到的Cesium依赖文件的想法是否是正确的，我是这样验证的： 用 npm run build 执行产品级的构建，在工程下构建出了 dist 目录； 从 node_modules/cesium/Build 中，拷贝Cesium目录到 dist 目录下, 你可以可以拷贝未压缩的，或者Source下的，应该都可以； 拷贝 dist 目录到 tomcat/webapps/ 中； 启动tomcat，打开 http://localhost:8080/dist 来查看； 这个时候我们发现，页面会报js路径找不到，原因是js路径不对，变成 http://localhost:8080/static/js/xxx.js 了，发现是 dist 那层被吃了。。。这肯定构建的路径有问题（可以打开看构建好的index.html的源代码，js的引用都是src=”/static/js/xxxxx.js”，这样就是从tomcat的web根目录来找了）。我们发现webpack配置中的output引用的是 config/index.js 中build的assetsPublicPath属性，这里赫然配置着 &quot;/&quot; ， 改成 &quot;./&quot; , 然后重新执行上述步骤， 哈哈，成功啦！ webpack-dev-server如果每次修改一段代码想看下效果，都得手工构建，然后重新部署到tomcat中看，我就问你烦不烦？一般人儿都烦，如果你骨骼惊奇，想法奇特，就当我没说，全文到此over。。。下面的内容是给一般人看的： 安装webpack-dev-servernpm install -D webpack-dev-server 添加配置文件可以有几种方案： 直接修改 build/webpack.dev.conf.js ，增加server配置，然后在package.json中配置启动server命令时，指定为该配置文件这个比较简单，但是配置的server启动命令会比较长。。。 模仿dev-server.js，用server的api接口来启动server这个需要学习webpack-dev-server的api接口，比较麻烦，但是后续想增加功能时，更灵活 与第一个方案类似，将 build/webpack.dev.conf.js 拷贝到工程根目录，改名，然后加server的配置这个是webpack-dev-server的默认方式，server会默认查找工程根目录下的webpack.config.js, webpack本身启动时，也是找个名称的配置文件的，所以一定要把文件名称改对了。 我们项目就是一个小页面，所以采用最后一个方案。 其他方案也都类似, 这里不再赘述。 配置webpack.config.js 将 build/webpack.dev.conf.js 拷贝到工程根目录，改名为 webpack.config.js； 增加server配置 module: { *** }, ***, devServer: { contentBase: config.dev.assetsRoot, // 代理的文件目录，直接使用构建的目录 port: config.dev.port, // 服务端口 historyApiFallback: true, // 不跳转 inline: true, // 实时刷新 hot: true, // 热加载 }, 虚拟项目名称 这个如果要用webpack-dev-server的热加载实时刷新功能（hmr，通俗讲就是启动服务器后，你一修改代码保存后，页面自动刷新，体现出你的修改，爽不？），就不能配置为 / 或者 ./, 必须给个字符串，比如我们这里的 assets , 我也不知道为什么，网上就这么说，实践也确实是这样。。。 具体的配置，有两种方式： webpack.config.js output: { path: config.dev.assetsRoot, publicPath: &apos;assets&apos;, // webpack-dev-server的hmr必须指定一个代理目录 }, config/index.js dev: { ***, assetsPublicPath: &apos;assets&apos;, // 默认的是&apos;/&apos; *** } 这里我们采用第一种方式，不修改config下的默认配置，使用自定义的配置来覆盖默认的。 自动拷贝静态文件配置 还记得上边步骤中，需要把Cesium的依赖文件拷贝到webpack构建的目录中吗？这里webpack可以在构建阶段帮你做。需要安装 copy-webpack-plugin 插件: npm install -D CopyWebpackPlugin 在webpack.config.js中引入插件： const CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;); *** plugins: [ ***, // copy custom static assets new CopyWebpackPlugin([{ from: path.resolve(__dirname, &apos;./static&apos;), to: config.build.assetsSubDirectory, ignore: [&apos;.*&apos;], }]), ], 从 /my-proj/node_modules/cesium/Build 中，拷贝Cesium目录到 /my-proj/static 目录下, ，并将这个目录加入版本管理工具。 这个拷贝在webpack.prod.conf.js是默认有的，因此不用再给其配置。 配置启动命令在package.json中，加入如下配置： &quot;scripts&quot;: { ***, &quot;webpack&quot;: &quot;webpack&quot;, &quot;server&quot;: &quot;webpack-dev-server --open&quot;, &quot;start&quot;: &quot;webpack &amp;&amp; webpack-dev-server --open&quot; }, 开发环境测试 npm start 构建成功。。。 服务器启动成功。。。 浏览器自动打开。。。 页面显示正确。。。。 以上，大功告成！！！","categories":[],"tags":[{"name":"技术总结","slug":"技术总结","permalink":"https://madshawn.github.io/tags/技术总结/"}]},{"title":"sublime的自动注释配置","slug":"sublime的自动注释配置","date":"2017-09-18T15:14:43.000Z","updated":"2018-03-15T05:57:03.806Z","comments":true,"path":"2017/09/18/sublime的自动注释配置/","link":"","permalink":"https://madshawn.github.io/2017/09/18/sublime的自动注释配置/","excerpt":"","text":"前言为了在sublime编辑器中能通过快捷键自动为js文件、类、函数等添加符合jsdoc规范的注释，需要安装的相关的插件，并进行自定义的配置。现将安装和配置的过程记录如下，以备不时之需。 文件头注释由于sublime的DocBlockr插件只支持对函数、变量的快捷注释，不能增加文件头注释，因此需要安装File header插件。 安装插件sumlime安装插件的方式： ctrl+shift+p组合键，或 prefences &gt; package control 者打开包管理窗口 输入 install package打开包安装窗口 输入 file header进行包搜索 选中fileheader插件启动安装 修改配置 在sublime菜单栏，点击 prefences &gt; browse packages 打开包目录 打开FileHeader &gt; template &gt; header 文件夹 找到javascript.tmpl文件，添加如下内容： 12345678/*** [Description]* @file &#123;&#123;file_name&#125;&#125;* @author xxxx* @date &#123;&#123;create_time&#125;&#125;** @copyright: @Navinfo, all rights reserved.*/ 注意：模版最后要加入三个空行，这样在js文件中插入此注释后才会加入一个空行 插件的使用可以在sublime的菜单 prefences &gt; package settings &gt; File Header &gt; key bingding-Default中，修改该插件的快捷键。你当然也可以直接用默认的。这里我们将command ‘file_header_add_header’ 的快捷键修改为 ‘ctrl+alt+h’。这样，在打开一个js文件后，按’ctrl+alt+h’组合键会打开为当前文件添加文件头注释的窗口，按enter即可完成文件头注释的插入。 函数注释安装插件安装sublime的DocBlockr插件，安装方法参考上一节 修改配置在sumlime菜单栏，打开 prefences &gt; package settings &gt; DocBlockr &gt; settings-user，打开用户配置文件，增加以下配置：12345678&#123; \"jsdocs_extra_tags\": [\"@author XXXX\", \"@date &#123;&#123;date&#125;&#125;\"], \"jsdocs_notation_map\": [&#123; \"prefix\": \"_\", \"tags\": [\"@private\"] &#125;], \"jsdocs_autoadd_method_tag\": true&#125; 配置的详细说明可参考README文件：prefences &gt; package settings &gt; DocBlockr &gt; README 插件的使用在需要增加注释的函数/变量定义的上一行，输入 /** ，然后按 Enter 键，即可添加默认的注释信息。需要手工补充函数、参数和返回值的数据类型和描述。 批量增加函数注释smartcomments是一个nodejs写的给文件的所有函数增加注释的工具，详细的说明可参考 smartcomment主页 和 github地址 安装npm install -g smartcomments 自定义配置默认的配置只支持4个@tag，不满足我们的注释需求，因此需要自定义。可以在需要批量加注释的项目下新建两个文件，smartcomments.json和templates.js，这里就不再做过多说明，直接贴出代码： smartcomments.json 1234567891011121314151617181920212223242526272829&#123; \"target_dir\": [ \"\" ], \"match_files\": [ \"^((?!~).)*.(js)$\" ], \"backup\": false, \"private\": false, \"favor_generated\": false, \"tags\": &#123; \"function\": &#123; \"name\": &#123;&#125;, \"desc\": &#123; // 函数的默认描述 \"value\": \"[Auto generated description]\" &#125;, \"author\": &#123; // 要指定的作者名字 \"value\": \"XXXX\" &#125;, \"date\": &#123;&#125;, \"params\": &#123;&#125;, \"rtrn\": &#123;&#125; &#125; &#125;, // 这里指向自定义的模版文件，要给出绝对地址，否则找不到 \"template\": \"E:\\\\xxxx\\\\template.js\"&#125; template.js 可以从smartcomments的github库中看到默认的default.js，拷贝一份命名为template.js，然后修改其中的 buildComment 函数即可，修改后的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697buildComment: function (data) &#123; var instance = templateInstance, // BaseTemplate instance config = instance.config, // User current config options = config.tags.function, // Custom functions tags options pos, // Empty comment obj comment = &#123; pos: data.pos, tags: [] &#125;, methodName = data.name, node = data.node; if (typeof (config.private) === 'undefined' || config.private || !/^_/.test(methodName)) &#123; // Description statement if (options.desc) &#123; comment.tags.push(&#123; name: '', value: options.desc.value || 'Function description' &#125;); &#125; // @method statement if (methodName &amp;&amp; options.name) &#123; comment.tags.push(&#123; name: '@method', value: methodName &#125;); &#125; // 增加作者tag // Author statement if (options.author) &#123; comment.tags.push(&#123; name: '@author', value: options.author.value || 'XXX' &#125;); &#125; // 增加日期tag // Date statement if (options.date) &#123; comment.tags.push(&#123; name: '@date', value: ' ' + (options.date.value || new Date().toLocaleDateString()) &#125;); &#125; var size, i = 0, value; // @param statement if (options.params) &#123; var array = node.params; size = array.length; for (i; i &lt; size; i++) &#123; value = ' &#123;[type]&#125; ' + array[i].name + ' [description]'; comment.tags.push(&#123; name: '@param', value: value &#125;); &#125; &#125; // @return statement if (options.rtrn) &#123; var elements = node.body.body; if (elements) &#123; size = elements.length; value = ''; for (i = 0; i &lt; size; i++) &#123; if (elements[i].type === 'ReturnStatement') &#123; if (elements[i].argument) &#123; value = '&#123;[type]&#125; [description]'; break; &#125; &#125; &#125; if (!value) &#123; value = '&#123;Undefined&#125; 无返回值'; &#125; comment.tags.push(&#123; name: '@return', value: value &#125;); &#125; &#125; if (comment.pos &gt;= 0) &#123; // Add comment to comment_list instance.comments_list.push(comment); &#125; &#125;&#125;, 修改smartcomments源代码最重要的部分来了。不得不吐槽一下smartcomments的源代码，真的代码烂烂，bug多多。。。由于smartcomments是用npm全局安装的，这里就需要修改全局包中的代码。查看npm全局包安装目录的命令： npm config get prefix 然后修改[prefix]\\node_modules\\smartcomments\\lib\\smartcomments.js文件。修改的内容比较多，就不一一说明了，主要修改了4个函数，直接上代码： 修改之前备份一下是个好习惯 mergeSrcAndGeneratedComment 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849mergeSrcAndGeneratedComment: function (instance, generatedComment, favorGenerated) &#123; var srcComment = generatedComment.srcComment, mergedCommentLines = []; // process each src comment line, and remove matching comments from generatedComment var srcCommentTags = _.map(srcComment.value.split(/\\r?\\n/), function (commentLine) &#123; return instance.parseTagNameValue(commentLine); &#125;); _.each(generatedComment.tags, function (tag) &#123; if (favorGenerated) &#123; mergedCommentLines.push(tag); &#125; else &#123; var srcTag; var f = false; var desc = []; for (var i = 0; i &lt; srcCommentTags.length; i++) &#123; srcTag = srcCommentTags[i]; if (tag.name === '' &amp;&amp; (srcTag.name === '' || srcTag.name === '@description')) &#123; desc.push(srcTag.value); f = true; &#125; else if (srcTag.name === tag.name) &#123; if (tag.name === '@param') &#123; if (instance.isSameParam(srcTag.value, tag.value)) &#123; f = true; break; &#125; &#125; else &#123; f = true; break; &#125; &#125; &#125; if (!f) &#123; mergedCommentLines.push(tag); &#125; else &#123; if (tag.name === '') &#123; tag.value = desc.join(''); mergedCommentLines.push(tag); &#125; else &#123; mergedCommentLines.push(srcTag); &#125; &#125; &#125; &#125;); instance.mergeOtherSrcTags(srcCommentTags, mergedCommentLines); generatedComment.tags = mergedCommentLines;&#125;, parseTagNameValue 123456789parseTagNameValue: function (commentLine) &#123; var clean = commentLine.replace(/^\\s*\\*?\\s?/, ''); // strip leading ' * ' var nameValueMatch = /^(?:(@\\w+))?([^\\r\\n]*)/.exec(clean); return &#123; name: nameValueMatch[1] || '', value: nameValueMatch[2] || '', &#125;;&#125;, isSameParam 1234567891011121314151617181920isSameParam: function (srcValue, genValue) &#123; var stripTypeRe = /\\S*\\s*\\&#123;\\[?[\\w:-]*\\]?\\&#125;\\s*/, matchValRe = /^[\\w:-]+/; srcValue = srcValue.replace(stripTypeRe, ''); genValue = genValue.replace(stripTypeRe, ''); srcValue = matchValRe.exec(srcValue); genValue = matchValRe.exec(genValue); if (srcValue &amp;&amp; genValue) &#123; srcValue = srcValue[0]; genValue = genValue[0]; if (srcValue) &#123; return (genValue &amp;&amp; srcValue === genValue); &#125; else &#123; return !genValue; &#125; &#125; return false;&#125;, mergeOtherSrcTags 12345678910111213141516171819mergeOtherSrcTags: function (srcCommentTags, mergedCommentLines) &#123; var k; for (k = 0; k &lt; mergedCommentLines.length &amp;&amp; mergedCommentLines[k].name !== '@method'; k++); var temp = mergedCommentLines.slice(); _.each(srcCommentTags, function (srcTag) &#123; var f = false; for (var i = 0; i &lt; temp.length; i++) &#123; if (srcTag.name === temp[i].name || (srcTag.name === '@description' &amp;&amp; temp[i].name === '')) &#123; f = true; break; &#125; &#125; if (!f) &#123; mergedCommentLines.splice(k++, 0, srcTag); &#125; &#125;);&#125;, smartcomments的使用 使用默认配置 smartcomments --generate 注意：会对执行此命令的目录下所有js文件增加函数注释，会递归遍历所有子目录 使用自定义配置 smartcomments --generate -c ./comments/smartcomments.json 如果把自定义配置文件放置在执行此命令的目录下，并命名为smartcomments.json时，则可以不用指定-c参数，程序会自动识别；如果在配置文件在其他目录，则需要指定 指定要增加注释的文件/目录 smartcomments --generate -c ./comments/smartcomments.json -t ./apps/editorCtrl.js 可以指定文件，也可以指定目录","categories":[],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://madshawn.github.io/tags/工具使用/"}]},{"title":"Javascript注释规范","slug":"Javascript注释规范","date":"2017-09-11T14:04:49.000Z","updated":"2018-03-15T05:57:03.805Z","comments":true,"path":"2017/09/11/Javascript注释规范/","link":"","permalink":"https://madshawn.github.io/2017/09/11/Javascript注释规范/","excerpt":"","text":"前言为了规范工作中的代码注释，使得代码注释符合JsDoC规范，从而可以自动生成Api文档，特制定本规范。本规范主要包含以下几个方面的规定： 文件注释 类注释 函数注释 公共变量的注释 文件注释 （必须有）文件注释主要用于对无明确的类结构的文件的注释，比如只有一个大对象定义的文件（如Application.js）、多个全局函数定义的文件（util.js）、Angular的各种对象文件（route、controller、directive、service等）。注释规范如下： 常规文件 /** * 定义web app全局命名空间，并在此空间下定义属性和函数，以便全局使用 * -author ChenXiao * -date 2017-09-11 * * -copyright @Navinfo, all rights reserved. */ var App = {}; // web app全局配置信息 App.Config = { appName: &apos;FM-WebEditor&apos;, Angular controller /** * 编辑页面的主controller * -author ChenXiao * -date 2017-09-11 * * -copyright @Navinfo, all rights reserved. */ angular.module(&apos;app&apos;).controller(&apos;editorCtrl&apos;, [&apos;$scope&apos;, &apos;$rootScope&apos;, &apos;$cookies&apos;, &apos;$timeout&apos;, &apos;$q&apos;, &apos;$ocLazyLoad&apos;, &apos;ngDialog&apos;, &apos;appPath&apos;, &apos;dsMeta&apos;, &apos;dsFcc&apos;, &apos;dsEdit&apos;, &apos;dsManage&apos;, &apos;dsColumn&apos;, &apos;dsLazyload&apos;, function ($scope, $rootScope, $cookies, $timeout, $q, $ocLazyLoad, ngDialog, appPath, dsMeta, dsFcc, dsEdit, dsManage, dsColumn, dsLazyload) { if (!$scope.testLogin()) { return; } 注释与controller之间必须要有个空行，否则jsdoc会把controller当成函数注释，导致jsdoc报错。 建议所有的文件头注释与代码之间要加一个空行。 类注释 （必须有，可以替代文件注释）类注释主要用于符合类结构的文件的注释，比如通过L.Class创建的模拟类的文件（mapRender、dataApi、uikit下的\b文件）。由于代码中基本上达到\b了一个类一个文件的结构，因此可以用类注释替代文件注释。注释的规范如下： /** * 交限的前端数据模型 * -author ChenXiao * -date 2017-09-11 * * -copyright @Navinfo, all rights reserved. */ FM.dataApi.RdRestrictionDetail = FM.dataApi.Feature.extend({ /** * 模型转换主函数，将接口返回的数据转换为前端数据模型 * -author ChenXiao * -date 2017-09-11 * @param {object} data 接口返回的数据 * @return {undefined} */ setAttributes: function (data) { this.geoLiveType = &apos;RDRESTRICTIONDETAIL&apos;; this.pid = data.pid || 0; this.restricPid = data.restricPid || 0; this.outLinkPid = data.outLinkPid || 0; 函数注释 （必须有）所有的函数都必须加此注释，要完全符合jsdoc规范。后续会把eslint打开，不符合要求的不予合并。注释规范如下： 一般情况 /** * 根据的窗口的选项，创建弹出窗口对象 * -author ChenXiao * -date 2017-09-11 * @param {object} data 窗口选项，主要为要显示的信息类型 * @return {object} 包含窗口标题、页面片段的信息的窗口对象 */ var createDialog = function (data) { var item = {}; var tmplFile = FM.uikit.Config.getUtilityTemplate(data.type); item.title = FM.uikit.Config.getUtilityName(data.type); item.ctrl = appPath.scripts + tmplFile.ctrl; item.tmpl = appPath.scripts + tmplFile.tmpl; item.options = FM.Util.clone(defaultDialogOptions); getDlgOptions(data.type, item.options); return item; }; 无返回值的情况 /** * 模型转换主函数，将接口返回的数据转换为前端数据模型 * -author ChenXiao * -date 2017-09-11 * @param {object} data 接口返回的数据 * @return {undefined} */ setAttributes: function (data) { this.geoLiveType = &apos;RDRESTRICTIONDETAIL&apos;; this.pid = data.pid || 0; this.restricPid = data.restricPid || 0; this.outLinkPid = data.outLinkPid || 0; 函数注释中，jsdoc要求必须有@return，因此无返回值时, return的类型要写为undefined。 无参数有返回值 /** * 将前端数据模型还原为接口数据模型 * -author ChenXiao * -date 2017-09-11 * @return {Object} 接口数据模型 */ getIntegrate: function () { var data = {}; data.pid = this.pid; 公共变量的注释公共变量我们分为三种，一种是全局变量（window下的），一种是类中的全局\b变量（如controller中），这两种必须加注释，第三种就是除了前两种之外的其他情况（比如一个函数中定义了多个内部函数，共享一变量），这种加不加注释可以视情况而定。注释规范如下： 单行注释 // 右侧面板是否开启标识 $scope.rightPanelFlag = false; // 右侧浮动面板是否开启标识 $scope.rightFloatPanelFlag = false; // 所有其他的右侧浮动面板 $scope.mapToolbarPanelFlag = false; $scope.clmPanelOpened = false; 多行注释 /* 右侧面板总控标识, 右侧面板对于页面的布局很重要， 加一个总控有可能在子页面种打开/关闭右侧面板 */ $scope.rightPanelOpened = false; // 将页面loading动画的开关引用赋给dsEdit的本地变量，以便在dsEdit中进行控制 // 注意：这里利用了对象引用的特性，变量必须是个对象，不能是字符串、bool、数字等 $scope.loading = { flag: false }; IDE中安装jsdoc辅助工具 sublime安装docBlockr安装fileHeader webstorm请补充 vscode请补充 jsdoc生成器 npm安装npm install -g jsdoc 参考npm jsdoc","categories":[],"tags":[{"name":"编码规范","slug":"编码规范","permalink":"https://madshawn.github.io/tags/编码规范/"}]},{"title":"Web组工作安排","slug":"Web组工作安排","date":"2017-09-08T17:03:39.000Z","updated":"2018-03-15T05:57:03.805Z","comments":true,"path":"2017/09/09/Web组工作安排/","link":"","permalink":"https://madshawn.github.io/2017/09/09/Web组工作安排/","excerpt":"","text":"17年下半年的主要任务 WebApp代码加注释 mapApi的代码、注释改善，对外开放api 日编平台 月编平台 代理店平台 元数据平台 代码的es6重构 产品、代码改善 课题研究 新技术的学习 工作安排WebApp代码加注释 参与人：全组 时间：9.11-9.15，一周时间 由cx给出样例，主要包含文件头注释、类注释、函数注释三种，文件头注释我们自定义，其他两种注释要完全符合jsdoc规范，以便后期自动生成\b文档 MapApi的代码、注释改善 参与人： ll 时间：9.11-9.15，先按一周来算，可能不够 主要目标是加深对mapApi原理、结构和代码的理解，可以先边读代码，边加注释，先理解，然后才能维护和改善。注释的方式参考前一节。 日编平台 参与人： ll,wmd,lz 时间：长期 主要负责日编的维护和\b新功能开发，ll主参与，md和lz部分参与 月编平台 参与人：wz,ml,lz,wmd 时间：长期 由wz带队开发，ml\b主参与，lz和md部分参与 代理店平台 参与人：wz,随机 时间：长期 wz主负责，视任务情况随机安排其他人参 元数据平台 参与人：ml，随机 时间：长期 ml主负责，视任务情况随机安排其他人参 代码的es6重构对代码\b\b进行es6语法的改写，用Class、module等对底层\b代码进行重构，方便以后更好的调用。先从dataApi、mapRender开始。 参与人： 全组 时间：915之后，预计用时2周 cx先确定一个重构方案，确定类的写法、类的继承\b关系的实现等等 产品、代码改善 产品功能以及代码改善 定期对目前所有实现的内容进行review，包括功能、代码、注释，发现问题改善问题，争取用一段时间把所有功能过一遍 地图渲染优化 短期：优化细节渲染函数，不断调优 长期：考虑webGL整体替换 界面加载优化 短期：合并相关JS和css代码，合并图标 长期：考虑相关代码改动频率，适时调整缓存策略 参与人： 全组 课题研究目前想到的有以下两个课题 地图的加载渲染方式 地图渲染压盖，要素内部、要素之间的 参与人：cx，其他人感兴趣可参与 \b时间：17年底 新技术学习 webgl,mapboxgl –必须学 vue react, react-native app开发 服务端程序开发，java/python/nodejs？","categories":[],"tags":[{"name":"工作计划","slug":"工作计划","permalink":"https://madshawn.github.io/tags/工作计划/"}]},{"title":"Hexo入门","slug":"first-page","date":"2017-09-05T17:44:22.000Z","updated":"2018-03-15T05:57:03.806Z","comments":true,"path":"2017/09/06/first-page/","link":"","permalink":"https://madshawn.github.io/2017/09/06/first-page/","excerpt":"","text":"搭建此\bBlog用到的网站：Hexo文档https://hexo.io/zh-cn/docs/主题-nexthttp://theme-next.iissnan.com/getting-started.html","categories":[],"tags":[]}]}